package gamejolt;

import gamejolt.formats.*;
import gamejolt.types.*;
import openfl.events.*;

using Lambda;
using StringTools;

/**
 * The GameJolt API Class where the global values for `GJRequest` instances are setted up.
 * @see For more info about the GameJolt API and calls: https://gamejolt.com/game-api
 */
class GameJolt {
	/**
	 * Your Game ID goes here.
	 */
	public static var gameID:Int = 0;

	/**
	 * Your Game Private Key goes here.
	 */
	public static var gameKey:String = "";

	/**
	 * If `true`, `GJRequest` instances will use `Md5` encryptation for request calls.
	 * Otherwise, they'll use `Sha1` encryptation instead.
	 */
	public static var usingMd5:Bool = true;

	/**
	 * The Username of the user.
	 */
	public static var userName:String = "";

	/**
	 * The Game Token of the user. \
	 * NOTE: If you leave this `null`, only the functions related to Scores are gonna be functional for the user. \
	 */
	public static var userToken:String = "";
}

/**
 * The general GameJolt class you can be able to make calls to its API from.
 * @see For more info about how to formulate calls correctly: https://github.com/GamerPablito/HaxeGJClient
 */
class GJRequest {
	/**
	 * The actual URL created by the parsing of the current `call`.
	 */
	public var url(get, never):String;

	/**
	 * The last response generated by `send()` spawns here.
	 */
	public var lastResponse(default, null):Response = {};

	/**
	 * The current instruction `this` is willing to execute. Cannot be modified while `executing == true`.
	 */
	public var call(default, set):RequestType;

	/**
	 * Whether if the current `url` is being executed by `send()` or not.
	 */
	public var executing(default, null):Bool = false;

	/**
	 * An event dispatcher you can set up to be called by `send()` when the current execution ends successfully.
	 */
	public dynamic function onComplete(res:Response) {}

	/**
	 * An event dispatcher you can set up to be called by `send()` while the current execution is progressing.
	 */
	public dynamic function onProgress(progress:Float, total:Float) {}

	/**
	 * An event dispatcher you can set up to be called by `send()` when the current execution ends with an error of any kind.
	 */
	public dynamic function onError(error:String) {}

	public function new(Call:RequestType)
		call = Call;

	function get_url():String
		return 'https://api.gamejolt.com/api/game/v1_2${parseType(call)}';

	function set_call(value:RequestType):RequestType {
		if (executing)
			return call;
		return call = value;
	}

	/**
	 * Sends the current `call` to the GameJolt API to return a `Response` from it, if `executing == false`.
	 * @return A `Future` instance that returns a `Response` from the GameJolt API while saving it in `lastResponse`.
	 */
	public function send() {
		if (executing)
			return;
		executing = true;

		sys.thread.Thread.create(function() {
			var loader = new openfl.net.URLLoader();
			loader.addEventListener(Event.COMPLETE, function(complete) {
				var response:Response = lastResponse = formatImages(cast haxe.Json.parse(loader.data).response);
				if (response.message != null) {
					var err:String = 'Response Error: ${response.message}';
					if (response.responses != null) {
						var index:Int = response.responses.findIndex(r -> r.message != null);
						if (index >= 0)
							err += ' (Request #$index: ${response.responses[index].message})';
					}
					onError(err);
				} else
					onComplete(response);

				executing = false;
			});
			loader.addEventListener(ProgressEvent.PROGRESS, progress -> onProgress(progress.bytesLoaded, progress.bytesTotal));
			loader.addEventListener(IOErrorEvent.IO_ERROR, function(ioError) {
				lastResponse = {message: 'IO Error: ${ioError.text}'}
				onError(lastResponse.message);
				executing = false;
			});
			loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityError -> {
				lastResponse = {message: 'Security Error: ${securityError.text}'}
				onError(lastResponse.message);
				executing = false;
			});
			loader.load(new openfl.net.URLRequest(url));
		});
	}

	/**
	 * Makes retrieved images to have a better resolution.
	 * @param oldRes The `Response` to be modified.
	 * @return A new `Response` with every Image URL modified for a better resolution when requested.
	 */
	function formatImages(oldRes:Response):Response {
		var res:Response = oldRes;
		if (res.users != null)
			res.users.iter(u -> u.avatar_url = '${u.avatar_url.substring(0, 32)}1000${u.avatar_url.substr(34)}'.replace(".jpg", ".png")
				.replace(".webp", ".png"));
		if (res.trophies != null)
			res.trophies.iter(function(t) {
				var newUrl:String = "";
				if (t.image_url.startsWith('https://m.'))
					newUrl = '${t.image_url.substring(0, 37)}1000${t.image_url.substr(40)}'.replace(".jpg", ".png").replace(".webp", ".png");
				else {
					newUrl = "https://s.gjcdn.net/assets/";
					newUrl += switch (t.image_url.substring(24).replace(".jpg", "").replace(".webp", "")) {
						case "trophy-bronze-1": "9c2c91d0";
						case "trophy-silver-1": "b46e352e";
						case "trophy-gold-1": "363ce2dc";
						case "trophy-platinum-1": "92e5330d";
						default: "";
					};
					newUrl += ".png";
				}
				t.image_url = newUrl;
			});
		if (res.responses != null)
			res.responses.iter(res2 -> res2 = formatImages(res2));
		return res;
	}

	/**
	 * Converts a `RequestType` instance into a piece of stringified URL.
	 * @param request The `RequestType` that will be converted to String.
	 * @param signed Whether to sign this conversion or not.
	 * @return The new URL piece.
	 */
	function parseType(request:RequestType, signed:Bool = false):String {
		var command:String = "";
		var action:String = "";
		var params:Array<{name:String, value:String}> = [];

		switch (request) {
			case BATCH(parallel, breakOnError, requests):
				command = "batch";
				params.push({name: "parallel", value: '$parallel'});
				params.push({name: "break_on_error", value: '$breakOnError'});
				for (req in requests)
					params.push({name: "requests[]", value: parseType(req, true)});
			case DATA_FETCH(key, fromUser):
				command = "data-store";
				params.push({name: "key", value: key.urlEncode()});
				if (fromUser) {
					params.push({name: "username", value: GameJolt.userName});
					params.push({name: "user_token", value: GameJolt.userToken});
				}
			case DATA_GETKEYS(fromUser, pattern):
				command = "data-store";
				action = "get-keys";
				if (pattern != null && pattern != "")
					params.push({name: "pattern", value: pattern.urlEncode()});
				if (fromUser) {
					params.push({name: "username", value: GameJolt.userName});
					params.push({name: "user_token", value: GameJolt.userToken});
				}
			case DATA_REMOVE(key, fromUser):
				command = "data-store";
				action = "remove";
				params.push({name: "key", value: key.urlEncode()});
				if (fromUser) {
					params.push({name: "username", value: GameJolt.userName});
					params.push({name: "user_token", value: GameJolt.userToken});
				}
			case DATA_SET(key, data, toUser):
				command = "data-store";
				action = "set";
				params.push({name: "key", value: key.urlEncode()});
				params.push({name: "data", value: data.urlEncode()});
				if (toUser) {
					params.push({name: "username", value: GameJolt.userName});
					params.push({name: "user_token", value: GameJolt.userToken});
				}
			case DATA_UPDATE(key, operation, toUser):
				command = "data-store";
				action = "update";
				params.push({name: "key", value: key.urlEncode()});
				if (toUser) {
					params.push({name: "username", value: GameJolt.userName});
					params.push({name: "user_token", value: GameJolt.userToken});
				}
				switch (operation) {
					case Add(n):
						params.push({name: 'operation', value: 'add'});
						params.push({name: 'value', value: '$n'});
					case Substract(n):
						params.push({name: 'operation', value: 'substract'});
						params.push({name: 'value', value: '$n'});
					case Multiply(n):
						params.push({name: 'operation', value: 'multiply'});
						params.push({name: 'value', value: '$n'});
					case Divide(n):
						params.push({name: 'operation', value: 'divide'});
						params.push({name: 'value', value: '$n'});
					case Append(t):
						params.push({name: 'operation', value: 'append'});
						params.push({name: 'value', value: t.urlEncode()});
					case Prepend(t):
						params.push({name: 'operation', value: 'prepend'});
						params.push({name: 'value', value: t.urlEncode()});
				}
			case FRIENDS:
				command = "friends";
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case TIME:
				command = "time";
			case USER_AUTH:
				command = "users";
				action = "auth";
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case USER_FETCH(userOrIDList):
				command = "users";
				if (userOrIDList != [])
					params.push({
						name: userOrIDList.exists(userOrID -> Std.parseInt(userOrID) == null) ? "username" : "user_id",
						value: userOrIDList.join(",").urlEncode()
					});
			case SESSION_OPEN:
				command = "sessions";
				action = "open";
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case SESSION_PING(active):
				command = "sessions";
				action = "ping";
				params.push({name: "status", value: active ? "active" : "idle"});
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case SESSION_CHECK:
				command = "sessions";
				action = "check";
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case SESSION_CLOSE:
				command = "sessions";
				action = "close";
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case SCORES_ADD(score, sort, extra_data, table_id):
				command = "scores";
				action = "add";
				params.push({name: "score", value: score});
				params.push({name: "sort", value: '$sort'});
				if (extra_data != null && extra_data != "")
					params.push({name: "extra_data", value: extra_data.urlEncode()});
				if (table_id != null)
					params.push({name: "table_id", value: '$table_id'});
				if (GameJolt.userToken != "") {
					params.push({name: "username", value: GameJolt.userName});
					params.push({name: "user_token", value: GameJolt.userToken});
				} else
					params.push({name: "guest", value: GameJolt.userName});
			case SCORES_GETRANK(sort, table_id):
				command = "scores";
				action = "get-rank";
				params.push({name: "sort", value: '$sort'});
				if (table_id != null)
					params.push({name: "table_id", value: '$table_id'});
			case SCORES_FETCH(fromUser, table_id, limit, betterThan):
				command = "scores";
				if (table_id != null)
					params.push({name: "table_id", value: '$table_id'});
				if (limit != null)
					params.push({name: "limit", value: '$limit'});
				if (betterThan != null)
					params.push({name: betterThan < 0 ? "worse_than" : "better_than", value: '${Math.abs(betterThan)}'});
				if (fromUser) {
					if (GameJolt.userToken != "") {
						params.push({name: "username", value: GameJolt.userName});
						params.push({name: "user_token", value: GameJolt.userToken});
					} else
						params.push({name: "guest", value: GameJolt.userName});
				}
			case SCORES_TABLES:
				command = "scores";
				action = "tables";
			case TROPHIES_FETCH(achieved, trophy_id):
				command = "trophies";
				if (achieved != null)
					params.push({name: "achieved", value: '$achieved'});
				if (trophy_id != null)
					params.push({name: "trophy_id", value: '$trophy_id'});
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case TROPHIES_ADD(trophy_id):
				command = "trophies";
				action = "add";
				params.push({name: "trophy_id", value: '$trophy_id'});
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
			case TROPHIES_REMOVE(trophy_id):
				command = "trophies";
				action = "remove";
				params.push({name: "trophy_id", value: '$trophy_id'});
				params.push({name: "username", value: GameJolt.userName});
				params.push({name: "user_token", value: GameJolt.userToken});
		}

		var urlSection:String = '/$command${action != "" ? '/$action' : ""}?game_id=${GameJolt.gameID}${[for (p in params) '&${p.name}=${p.value}'].join("")}';
		if (signed)
			urlSection = sign(urlSection);
		return urlSection;
	}

	/**
	 * Signs a piece of URL according to `usingMd5` parameter of the `GameJolt` class.
	 * @param daUrl The old URL piece.
	 * @return The new URL piece.
	 */
	function sign(daUrl:String):String {
		var urlToEncode:String = daUrl + GameJolt.gameKey;
		return '$daUrl&signature=${GameJolt.usingMd5 ? haxe.crypto.Md5.encode(urlToEncode) : haxe.crypto.Sha1.encode(urlToEncode)}'.urlEncode();
	}
}
